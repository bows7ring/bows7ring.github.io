<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SGX2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/18/SGX2/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T12:48:40.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/18/SGX2/">SGX2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/SGX2/" data-id="ckyk45jzn0001t8do1onn5chs" data-title="SGX2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/18/test2/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T10:33:31.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/18/test2/">test2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/test2/" data-id="ckyk42t8200016wdoae38029g" data-title="test2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Post-0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/18/Post-0/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T06:07:42.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/18/Post-0/">SGX2.0 调研笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SGX-2-0-概述："><a href="#SGX-2-0-概述：" class="headerlink" title="SGX 2.0 概述："></a>SGX 2.0 概述：</h1><blockquote>
<p> 相较于初代的SGX服务单机最多256MB的EPC内存限制，此次基于SGX2.0技术的EPC内存最多可以达到1T，彻底解决限制大数据及相关应用的内存问题。</p>
</blockquote>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul>
<li>Intel® Software Guard Extensions (Intel® SGX) Support for Dynamic Memory Management Inside an Enclave （官方论文，介绍enclave 2.0的内存管理）</li>
<li><a target="_blank" rel="noopener" href="https://caslab.csl.yale.edu/workshops/hasp2016/HASP16-16_slides.pdf">HASP16-16_slides.pdf (yale.edu)</a></li>
</ul>
<h2 id="0，总结："><a href="#0，总结：" class="headerlink" title="0，总结："></a>0，总结：</h2><p>SGX 2将内存管理划分为内、外两部分，系统资源由系统管理、enclave资源在enclave内部管理：</p>
<ul>
<li>外部MM：负责创建enclave时候的内存分配（默认创建最小的enclave）<ul>
<li>分配内存、内存分页、更改权限和更改页面类型。</li>
</ul>
</li>
<li>内部MM：发起内存更改请求（等待外部完成），并检验。</li>
</ul>
<hr>
<p><strong>设计理念：</strong>想要做到(i)更安全，(ii)更灵活的同时还能减少对OS的依赖，(iii)减少安全管理、系统服务之间的耦合，enclave就需要自己完成更多的功能，<strong>也就是自治</strong>。比如本文所讨论的内存管理。</p>
<h2 id="1，What‘s-New"><a href="#1，What‘s-New" class="headerlink" title="1，What‘s New"></a>1，What‘s New</h2><p><img src="D:\GitHub\source\images\sgx2.1.png" alt="image-20220117154225802"></p>
<p>区别如图，SGX1的缺点主要有2点，(i)所有enclave内存需要在enclave创建时确定，费时间，并且开销在有限的EPC上(ii)不能灵活适用于多场景，需按最坏情况分配资源。否则开发者要为不同的负载设计不同的软件。</p>
<h2 id="2，方案：enclave内存自治"><a href="#2，方案：enclave内存自治" class="headerlink" title="2，方案：enclave内存自治"></a>2，方案：enclave内存自治</h2><p>内存管理功能必须拆分为：管理系统资源的系统内存资源管理器（系统管理器）和从飞地内部管理飞地内存的内部飞地资源管理器（内部管理器）。</p>
<p>需要一个由系统管理器和内部管理器之间的通信组成的协议。来完成如图的内存管理流程中的权限交接。</p>
<p><img src="D:\GitHub\source\images\sgx2.jpg" alt="image-20220117152942714"></p>
<h2 id="3，自治需要做到："><a href="#3，自治需要做到：" class="headerlink" title="3，自治需要做到："></a>3，自治需要做到：</h2><ul>
<li>enclave需要自己掌控其内存和权限<em>【自己实现部分功能】</em></li>
<li>enclave代码在enclave不知情的情况下被改变时，将不会被执行<em>【代码、页完整性】</em></li>
<li>系统的资源管理器能够正常管理和分配资源<em>【系统基础权限，该有的还得有】</em></li>
<li>需要同时有EPCM权限和系统权限才能更改内存权限<em>【权限管理】</em></li>
</ul>
<h2 id="4，通过EDMM实现应用程序的内存管理，需要实现："><a href="#4，通过EDMM实现应用程序的内存管理，需要实现：" class="headerlink" title="4，通过EDMM实现应用程序的内存管理，需要实现："></a>4，通过EDMM实现应用程序的内存管理，需要实现：</h2><ul>
<li><p>内存管理操作：</p>
<ul>
<li>Page allocation and deallocation</li>
<li>Thread (TCS) creation/destruction </li>
<li>Page permissions modification</li>
</ul>
</li>
<li><p>OS和enclave的协作（权限交接）：</p>
<ul>
<li>enclave发起申请，OS代为实现。</li>
<li>enclave验收后，更改才生效。</li>
</ul>
</li>
<li><p>enclave内存管理模块应该隐藏用户代码复杂性（Enclave memory manager hides complexity from application code）</p>
</li>
</ul>
<h2 id="5，安全考虑-amp-新方案"><a href="#5，安全考虑-amp-新方案" class="headerlink" title="5，安全考虑 &amp; 新方案"></a>5，安全考虑 &amp; 新方案</h2><ul>
<li>保证了enclave代码和数据页面的完整性。（对应keystone中enclave加载的ELF文件？）</li>
<li>通过度量，保障enclave内存的完整性。（内存初始化要度量）</li>
<li>OS相关：OS必需参与页表度量、TLB刷新，不能信任OS</li>
</ul>
<p>上述问题的解决方案：enclave监视完整过程：enclave发起申请 -&gt; OS执行 -&gt; enclave验收。</p>
<h2 id="6，EAPP需要考虑的事情"><a href="#6，EAPP需要考虑的事情" class="headerlink" title="6，EAPP需要考虑的事情"></a>6，EAPP需要考虑的事情</h2><ul>
<li><p>有时需要更改页面熟悉，有时需要拓展内存。这些都有专门的SGX2指令来完成。</p>
</li>
<li><p>enclave内部异常报告。EAPP可自己检测异常，完成相应的管理操作。</p>
</li>
<li><p>按需加载库页面。【没看懂，感觉类似于Copy On Write，能否把这个理解为，Load on PageFault？】</p>
<blockquote>
<p><strong>Demand Loading of Library Pages</strong></p>
<p>Library pages are loaded on demand when the program touches the page. When page fault occurs software would like to load the page into the location of the fault. The internal manager must have a </p>
<p>mechanism to load the page without allowing access until the copy is complete. SGX2 adds a leaf function to perform the copy securely. See section 3.5 for detailed steps.</p>
</blockquote>
</li>
</ul>
<h1 id="SGX-2-0-细节："><a href="#SGX-2-0-细节：" class="headerlink" title="SGX 2.0 细节："></a>SGX 2.0 细节：</h1><h2 id="0，新指令："><a href="#0，新指令：" class="headerlink" title="0，新指令："></a>0，新指令：</h2><p><img src="D:\GitHub\source\images\sgx3.png" alt="image-20220117165231955"></p>
<h2 id="1，Flow图："><a href="#1，Flow图：" class="headerlink" title="1，Flow图："></a>1，Flow图：</h2><p><img src="D:\GitHub\source\images\sgx.png" alt="image-20220117165331687"></p>
<h2 id="2，内存管理各功能的实现："><a href="#2，内存管理各功能的实现：" class="headerlink" title="2，内存管理各功能的实现："></a>2，内存管理各功能的实现：</h2><h3 id="Enclave-Malloc："><a href="#Enclave-Malloc：" class="headerlink" title="Enclave Malloc："></a><strong>Enclave Malloc</strong>：</h3><p>要实现 allocation + commit。需要EAUG + EACCPET。</p>
<h3 id="Enclave-Free："><a href="#Enclave-Free：" class="headerlink" title="Enclave Free："></a><strong>Enclave Free</strong>：</h3><p>SGX1就能释放commited mem了。SGX2的更健壮。</p>
<ul>
<li><p>EMODT：用于修改页面的EPCM，以准备删除它。</p>
</li>
<li><p>SGX2扩展版本的ETRACK：由于页面的映射可能缓存在TLB中，SGX2 extends ETRACK to track the flushing of TLBs when restrict accessing pages with EMODT and EMODPR。</p>
</li>
<li><p>EACCEPT：确认TLB映射已经清除。</p>
</li>
</ul>
<h3 id="Changing-Page-Permissions："><a href="#Changing-Page-Permissions：" class="headerlink" title="Changing Page Permissions："></a><strong>Changing Page Permissions</strong>：</h3><p>更新页面内容，清除页面的write权限。</p>
<blockquote>
<p>eg：enclave的runtime可能有垃圾回收模块，这需要定期将页面标记为只读的，然后恢复对页面的写入权限。</p>
</blockquote>
<h3 id="Thread-Control-Structure-Allocation"><a href="#Thread-Control-Structure-Allocation" class="headerlink" title="Thread Control Structure Allocation:"></a><strong>Thread Control Structure Allocation</strong>:</h3><p>SGX2支持对TCS（线程控制结构体）的分配，实现与页面限制很像，只不过OS不执行EMODPR，OS执行的是EMODT。</p>
<p>enclave内存管理器首先在enclave线性地址中选择一个4K页面，并使用适当的TCS值初始化该页面。TCS配置值包括状态保存区域的大小和位置、TCS的飞地入口点以及FS/GS基础值。一旦enclave内部管理器确定了一个可接受的地址，就可以使用SGX规定的协议完成TCS的分配（略）</p>
<h3 id="Dynamic-Loading-of-Modules："><a href="#Dynamic-Loading-of-Modules：" class="headerlink" title="Dynamic Loading of Modules："></a><strong>Dynamic Loading of Modules</strong>：</h3><p>为了支持模块的动态加载，SGX2提供了EACCEPTCOPY，允许内部管理器原子初始化页面的内容和权限。</p>
<h3 id="Library-OS-Support："><a href="#Library-OS-Support：" class="headerlink" title="Library OS Support："></a><strong>Library OS Support</strong>：</h3><p>Lib OS提供了一种新的容器类型，其中应用程序与在用户级别（ring 3）中执行的操作系统运行时捆绑在一起。启用SGX的Lib OS的一个关键要求是提供安全的异常处理。尤其是，LIB OS的异常处理程序必须能够安全地确定：（1）异常是由enclave引起的、（2）异常类型（例如page fault）、（3）fault信息。</p>
<blockquote>
<p> SGX2’s enhanced enclave exception handling provides the enclave runtime information about exceptions occurring inside the enclave. This secure reporting of exceptions allows enclave runtime systems to invoke application exception handlers without relying on the external exception handling system. </p>
</blockquote>
<h2 id="3，补充："><a href="#3，补充：" class="headerlink" title="3，补充："></a>3，补充：</h2><h3 id="非enclave的堆内存申请："><a href="#非enclave的堆内存申请：" class="headerlink" title="非enclave的堆内存申请："></a>非enclave的堆内存申请：</h3><p>用runtime库中的接口申请，如malloc。向OS请求，OS返回一个指针，指向新申请的内存。</p>
<p><img src="D:\GitHub\source\images\sgxmem.png" alt="image-20220117171633389"></p>
<h3 id="enclave的堆内存申请："><a href="#enclave的堆内存申请：" class="headerlink" title="enclave的堆内存申请："></a>enclave的堆内存申请：</h3><p>当然要使用enclave的runtime库中的接口了，用EAUG加个页面，多一些与底层硬件的交互。</p>
<p>在enclave接受新的内存之前，要EACCEPT，接受对正在运行的enclave的页面类型修改。</p>
<p><img src="D:\GitHub\source\images\enclave-alloc.png" alt="image-20220117171841776"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/Post-0/" data-id="ckyk42t7y00006wdogpemcxpy" data-title="SGX2.0 调研笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TEE%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" rel="tag">TEE论文笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SGX2内存管理笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/18/SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T06:07:42.000Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/18/SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/">SGX2内存管理笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SGX-2-0-概述："><a href="#SGX-2-0-概述：" class="headerlink" title="SGX 2.0 概述："></a>SGX 2.0 概述：</h1><blockquote>
<p> 相较于初代的SGX服务单机最多256MB的EPC内存限制，此次基于SGX2.0技术的EPC内存最多可以达到1T，彻底解决限制大数据及相关应用的内存问题。</p>
</blockquote>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul>
<li>Intel® Software Guard Extensions (Intel® SGX) Support for Dynamic Memory Management Inside an Enclave （官方论文，介绍enclave 2.0的内存管理）</li>
<li><a target="_blank" rel="noopener" href="https://caslab.csl.yale.edu/workshops/hasp2016/HASP16-16_slides.pdf">HASP16-16_slides.pdf (yale.edu)</a></li>
</ul>
<h2 id="0，总结："><a href="#0，总结：" class="headerlink" title="0，总结："></a>0，总结：</h2><p>SGX 2将内存管理划分为内、外两部分，系统资源由系统管理、enclave资源在enclave内部管理：</p>
<ul>
<li>外部MM：负责创建enclave时候的内存分配（默认创建最小的enclave）<ul>
<li>分配内存、内存分页、更改权限和更改页面类型。</li>
</ul>
</li>
<li>内部MM：发起内存更改请求（等待外部完成），并检验。</li>
</ul>
<hr>
<p><strong>设计理念：</strong>想要做到(i)更安全，(ii)更灵活的同时还能减少对OS的依赖，(iii)减少安全管理、系统服务之间的耦合，enclave就需要自己完成更多的功能，<strong>也就是自治</strong>。比如本文所讨论的内存管理。</p>
<h2 id="1，What‘s-New"><a href="#1，What‘s-New" class="headerlink" title="1，What‘s New"></a>1，What‘s New</h2><p><img src="SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%5Csgx2.1.png" alt="image-20220117154225802"></p>
<p>区别如图，SGX1的缺点主要有2点，(i)所有enclave内存需要在enclave创建时确定，费时间，并且开销在有限的EPC上(ii)不能灵活适用于多场景，需按最坏情况分配资源。否则开发者要为不同的负载设计不同的软件。</p>
<h2 id="2，方案：enclave内存自治"><a href="#2，方案：enclave内存自治" class="headerlink" title="2，方案：enclave内存自治"></a>2，方案：enclave内存自治</h2><p>内存管理功能必须拆分为：管理系统资源的系统内存资源管理器（系统管理器）和从飞地内部管理飞地内存的内部飞地资源管理器（内部管理器）。</p>
<p>需要一个由系统管理器和内部管理器之间的通信组成的协议。来完成如图的内存管理流程中的权限交接。</p>
<p><img src="SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%5Csgx2.jpg" alt="image-20220117152942714"></p>
<h2 id="3，自治需要做到："><a href="#3，自治需要做到：" class="headerlink" title="3，自治需要做到："></a>3，自治需要做到：</h2><ul>
<li>enclave需要自己掌控其内存和权限<em>【自己实现部分功能】</em></li>
<li>enclave代码在enclave不知情的情况下被改变时，将不会被执行<em>【代码、页完整性】</em></li>
<li>系统的资源管理器能够正常管理和分配资源<em>【系统基础权限，该有的还得有】</em></li>
<li>需要同时有EPCM权限和系统权限才能更改内存权限<em>【权限管理】</em></li>
</ul>
<h2 id="4，通过EDMM实现应用程序的内存管理，需要实现："><a href="#4，通过EDMM实现应用程序的内存管理，需要实现：" class="headerlink" title="4，通过EDMM实现应用程序的内存管理，需要实现："></a>4，通过EDMM实现应用程序的内存管理，需要实现：</h2><ul>
<li><p>内存管理操作：</p>
<ul>
<li>Page allocation and deallocation</li>
<li>Thread (TCS) creation/destruction </li>
<li>Page permissions modification</li>
</ul>
</li>
<li><p>OS和enclave的协作（权限交接）：</p>
<ul>
<li>enclave发起申请，OS代为实现。</li>
<li>enclave验收后，更改才生效。</li>
</ul>
</li>
<li><p>enclave内存管理模块应该隐藏用户代码复杂性（Enclave memory manager hides complexity from application code）</p>
</li>
</ul>
<h2 id="5，安全考虑-amp-新方案"><a href="#5，安全考虑-amp-新方案" class="headerlink" title="5，安全考虑 &amp; 新方案"></a>5，安全考虑 &amp; 新方案</h2><ul>
<li>保证了enclave代码和数据页面的完整性。（对应keystone中enclave加载的ELF文件？）</li>
<li>通过度量，保障enclave内存的完整性。（内存初始化要度量）</li>
<li>OS相关：OS必需参与页表度量、TLB刷新，不能信任OS</li>
</ul>
<p>上述问题的解决方案：enclave监视完整过程：enclave发起申请 -&gt; OS执行 -&gt; enclave验收。</p>
<h2 id="6，EAPP需要考虑的事情"><a href="#6，EAPP需要考虑的事情" class="headerlink" title="6，EAPP需要考虑的事情"></a>6，EAPP需要考虑的事情</h2><ul>
<li><p>有时需要更改页面熟悉，有时需要拓展内存。这些都有专门的SGX2指令来完成。</p>
</li>
<li><p>enclave内部异常报告。EAPP可自己检测异常，完成相应的管理操作。</p>
</li>
<li><p>按需加载库页面。【没看懂，感觉类似于Copy On Write，能否把这个理解为，Load on PageFault？】</p>
<blockquote>
<p><strong>Demand Loading of Library Pages</strong></p>
<p>Library pages are loaded on demand when the program touches the page. When page fault occurs software would like to load the page into the location of the fault. The internal manager must have a </p>
<p>mechanism to load the page without allowing access until the copy is complete. SGX2 adds a leaf function to perform the copy securely. See section 3.5 for detailed steps.</p>
</blockquote>
</li>
</ul>
<h1 id="SGX-2-0-细节："><a href="#SGX-2-0-细节：" class="headerlink" title="SGX 2.0 细节："></a>SGX 2.0 细节：</h1><h2 id="0，新指令："><a href="#0，新指令：" class="headerlink" title="0，新指令："></a>0，新指令：</h2><p><img src="SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%5Csgx3.png" alt="image-20220117165231955"></p>
<h2 id="1，Flow图："><a href="#1，Flow图：" class="headerlink" title="1，Flow图："></a>1，Flow图：</h2><p><img src="SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%5Csgx.png" alt="image-20220117165331687"></p>
<h2 id="2，内存管理各功能的实现："><a href="#2，内存管理各功能的实现：" class="headerlink" title="2，内存管理各功能的实现："></a>2，内存管理各功能的实现：</h2><h3 id="Enclave-Malloc："><a href="#Enclave-Malloc：" class="headerlink" title="Enclave Malloc："></a><strong>Enclave Malloc</strong>：</h3><p>要实现 allocation + commit。需要EAUG + EACCPET。</p>
<h3 id="Enclave-Free："><a href="#Enclave-Free：" class="headerlink" title="Enclave Free："></a><strong>Enclave Free</strong>：</h3><p>SGX1就能释放commited mem了。SGX2的更健壮。</p>
<ul>
<li><p>EMODT：用于修改页面的EPCM，以准备删除它。</p>
</li>
<li><p>SGX2扩展版本的ETRACK：由于页面的映射可能缓存在TLB中，SGX2 extends ETRACK to track the flushing of TLBs when restrict accessing pages with EMODT and EMODPR。</p>
</li>
<li><p>EACCEPT：确认TLB映射已经清除。</p>
</li>
</ul>
<h3 id="Changing-Page-Permissions："><a href="#Changing-Page-Permissions：" class="headerlink" title="Changing Page Permissions："></a><strong>Changing Page Permissions</strong>：</h3><p>更新页面内容，清除页面的write权限。</p>
<blockquote>
<p>eg：enclave的runtime可能有垃圾回收模块，这需要定期将页面标记为只读的，然后恢复对页面的写入权限。</p>
</blockquote>
<h3 id="Thread-Control-Structure-Allocation"><a href="#Thread-Control-Structure-Allocation" class="headerlink" title="Thread Control Structure Allocation:"></a><strong>Thread Control Structure Allocation</strong>:</h3><p>SGX2支持对TCS（线程控制结构体）的分配，实现与页面限制很像，只不过OS不执行EMODPR，OS执行的是EMODT。</p>
<p>enclave内存管理器首先在enclave线性地址中选择一个4K页面，并使用适当的TCS值初始化该页面。TCS配置值包括状态保存区域的大小和位置、TCS的飞地入口点以及FS/GS基础值。一旦enclave内部管理器确定了一个可接受的地址，就可以使用SGX规定的协议完成TCS的分配（略）</p>
<h3 id="Dynamic-Loading-of-Modules："><a href="#Dynamic-Loading-of-Modules：" class="headerlink" title="Dynamic Loading of Modules："></a><strong>Dynamic Loading of Modules</strong>：</h3><p>为了支持模块的动态加载，SGX2提供了EACCEPTCOPY，允许内部管理器原子初始化页面的内容和权限。</p>
<h3 id="Library-OS-Support："><a href="#Library-OS-Support：" class="headerlink" title="Library OS Support："></a><strong>Library OS Support</strong>：</h3><p>Lib OS提供了一种新的容器类型，其中应用程序与在用户级别（ring 3）中执行的操作系统运行时捆绑在一起。启用SGX的Lib OS的一个关键要求是提供安全的异常处理。尤其是，LIB OS的异常处理程序必须能够安全地确定：（1）异常是由enclave引起的、（2）异常类型（例如page fault）、（3）fault信息。</p>
<blockquote>
<p> SGX2’s enhanced enclave exception handling provides the enclave runtime information about exceptions occurring inside the enclave. This secure reporting of exceptions allows enclave runtime systems to invoke application exception handlers without relying on the external exception handling system. </p>
</blockquote>
<h2 id="3，补充："><a href="#3，补充：" class="headerlink" title="3，补充："></a>3，补充：</h2><h3 id="非enclave的堆内存申请："><a href="#非enclave的堆内存申请：" class="headerlink" title="非enclave的堆内存申请："></a>非enclave的堆内存申请：</h3><p>用runtime库中的接口申请，如malloc。向OS请求，OS返回一个指针，指向新申请的内存。</p>
<p><img src="SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%5Csgxmem.png" alt="image-20220117171633389"></p>
<h3 id="enclave的堆内存申请："><a href="#enclave的堆内存申请：" class="headerlink" title="enclave的堆内存申请："></a>enclave的堆内存申请：</h3><p>当然要使用enclave的runtime库中的接口了，用EAUG加个页面，多一些与底层硬件的交互。</p>
<p>在enclave接受新的内存之前，要EACCEPT，接受对正在运行的enclave的页面类型修改。</p>
<p><img src="SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%5Cenclave-alloc.png" alt="image-20220117171841776"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/" data-id="ckyk45jzk0000t8do92uvhhls" data-title="SGX2内存管理笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TEE%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" rel="tag">TEE论文笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/18/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-01-18T05:23:54.296Z" itemprop="datePublished">2022-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/18/hello-world/" data-id="ckyk42t8500036wdo49rz9fmm" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/TEE%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" rel="tag">TEE论文笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/TEE%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">TEE论文笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/18/SGX2/">SGX2</a>
          </li>
        
          <li>
            <a href="/2022/01/18/test2/">test2</a>
          </li>
        
          <li>
            <a href="/2022/01/18/Post-0/">SGX2.0 调研笔记</a>
          </li>
        
          <li>
            <a href="/2022/01/18/SGX2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/">SGX2内存管理笔记</a>
          </li>
        
          <li>
            <a href="/2022/01/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>